<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>K-Means Clustering Demo</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f8f8f8; margin: 0; padding: 0; }
    .container { max-width: 800px; margin: 40px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #ccc; padding: 24px; }
    h1 { text-align: center; }
    #controls { display: flex; justify-content: center; gap: 16px; margin-bottom: 16px; }
    button, select { font-size: 1rem; padding: 8px 16px; border-radius: 4px; border: 1px solid #888; background: #eee; cursor: pointer; }
    button:active { background: #ddd; }
    #graph { display: block; margin: 0 auto; background: #fafafa; border: 1px solid #ccc; border-radius: 8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>K-Means Clustering Demo</h1>
    <div id="controls">
  <label for="num-points">Points:</label>
  <input type="number" id="num-points" min="100" max="1000" value="100" style="width:80px;">
  <label for="k-select">K:</label>
  <select id="k-select"></select>
  <button id="place-centroids">K</button>
  <button id="match">Match</button>
  <button id="move">Move</button>
  <button id="reset">Start Over</button>
    </div>
    <canvas id="graph" width="700" height="500"></canvas>
  </div>
  <script>
    // --- Utility Functions ---
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function dist(a, b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }
    function mean(points) {
      if (points.length === 0) return {x: 0, y: 0};
      let sx = 0, sy = 0;
      for (const p of points) { sx += p.x; sy += p.y; }
      return { x: sx/points.length, y: sy/points.length };
    }

    // --- State ---
    let points = [];
    let centroids = [];
    let assignments = [];
    let K = 2;
    let matched = false;

    // --- DOM Elements ---
  const canvas = document.getElementById('graph');
  const ctx = canvas.getContext('2d');
  const numPointsInput = document.getElementById('num-points');
  const kSelect = document.getElementById('k-select');
  const btnPlace = document.getElementById('place-centroids');
  const btnMatch = document.getElementById('match');
  const btnMove = document.getElementById('move');
  const btnReset = document.getElementById('reset');

    // --- Setup K selector ---
    for (let i = 2; i <= 9; ++i) {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = i;
      kSelect.appendChild(opt);
    }
    kSelect.value = K;
    kSelect.onchange = () => { K = parseInt(kSelect.value); };

    // --- Generate random points ---
    function genPoints() {
      points = [];
      const N = Math.max(100, Math.min(1000, parseInt(numPointsInput.value) || 100));
      // Number of blobs (clusters for generation)
      const numBlobs = Math.min(K, Math.max(2, Math.floor(N/50)));
      // Generate blob centers
      const blobCenters = [];
      for (let i = 0; i < numBlobs; ++i) {
        blobCenters.push({
          x: randInt(100, canvas.width-100),
          y: randInt(100, canvas.height-100)
        });
      }
      // Assign points to blobs
      for (let i = 0; i < N; ++i) {
        const blobIdx = randInt(0, numBlobs-1);
        const center = blobCenters[blobIdx];
        // Gaussian spread around center
        const angle = Math.random() * 2 * Math.PI;
        const radius = Math.random() * 50 + Math.random() * 30; // more concentrated
        const x = center.x + Math.cos(angle) * radius + randInt(-8,8);
        const y = center.y + Math.sin(angle) * radius + randInt(-8,8);
        points.push({ x: Math.max(20, Math.min(canvas.width-20, x)), y: Math.max(20, Math.min(canvas.height-20, y)) });
      }
    }

    // --- Place centroids ---
    function placeCentroids() {
      centroids = [];
      for (let i = 0; i < K; ++i) {
        centroids.push({
          x: randInt(50, canvas.width-50),
          y: randInt(50, canvas.height-50)
        });
      }
      assignments = Array(points.length).fill(-1);
      matched = false;
      draw();
    }

    // --- Match points to centroids ---
    function matchPoints() {
      assignments = points.map(p => {
        let minD = Infinity, idx = -1;
        centroids.forEach((c, i) => {
          const d = dist(p, c);
          if (d < minD) { minD = d; idx = i; }
        });
        return idx;
      });
      matched = true;
      draw();
    }

    // --- Move centroids ---
    function moveCentroids() {
      for (let i = 0; i < K; ++i) {
        const assigned = points.filter((_, j) => assignments[j] === i);
        if (assigned.length > 0) {
          centroids[i] = mean(assigned);
        }
      }
      draw();
    }

    // --- Reset everything ---
    function resetAll() {
      genPoints();
      centroids = [];
      assignments = Array(points.length).fill(-1);
      matched = false;
      draw();
    }

    // --- Draw ---
    // --- Cluster Colors ---
    const clusterColors = [
      '#e74c3c', '#3498db', '#27ae60', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#fd79a8'
    ];

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Draw lines if matched
      if (matched) {
        for (let i = 0; i < points.length; ++i) {
          const cIdx = assignments[i];
          if (cIdx !== -1) {
            ctx.beginPath();
            ctx.moveTo(points[i].x, points[i].y);
            ctx.lineTo(centroids[cIdx].x, centroids[cIdx].y);
            ctx.strokeStyle = clusterColors[cIdx % clusterColors.length];
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      }
      // Draw points
      for (let i = 0; i < points.length; ++i) {
        const p = points[i];
        const cIdx = assignments[i];
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, 2*Math.PI); // smaller points
        ctx.fillStyle = (matched && cIdx !== -1) ? clusterColors[cIdx % clusterColors.length] : '#888';
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.stroke();
      }
      // Draw centroids
      for (let i = 0; i < centroids.length; ++i) {
        const c = centroids[i];
        ctx.beginPath();
        ctx.arc(c.x, c.y, 12, 0, 2*Math.PI); // smaller centroids
        ctx.fillStyle = clusterColors[i % clusterColors.length];
        ctx.shadowColor = '#222';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = '#222';
        ctx.fillText('C'+(i+1), c.x-14, c.y-16);
      }
    }

    // --- Event Listeners ---
    btnPlace.onclick = placeCentroids;
    btnMatch.onclick = matchPoints;
    btnMove.onclick = moveCentroids;
    btnReset.onclick = resetAll;

    // --- Initial State ---
    resetAll();
  </script>
</body>
</html>
